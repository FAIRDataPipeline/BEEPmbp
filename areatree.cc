// This code generate a hierarchical representation of areas at different levels of spatial scale
// This is used when samping infection events under IND_MODEL

#include <iostream>
#include <algorithm>

#include "math.h"

using namespace std;

#include "areatree.hh"

/// Initialises a tree of levels in which the entire population is subdivied onto a finer and finer scale
AreaTree::AreaTree(const Data &data) : data(data)
{
	lev.push_back(Level ());                                       // First level contains a single node with all the areas

	TreeNode node;
	for(auto h = 0u; h < data.narea; h++) node.arearef.push_back(h);      
	node.parent = UNSET;
	lev[0].node.push_back(node);

	auto l = 0u;
	unsigned int flag;
	do{
		lev.push_back(Level ());
		
		flag = 0;
		
		// The next level contains four child nodes 
		// These are generated by taking the areas in the current node and 
		// divivding them first horizontally and then vertically to generate four sub groups 
		for(auto c = 0u; c < lev[l].node.size(); c++){  
			geo_sort(lev[l].node[c].arearef,X);
			auto num = lev[l].node[c].arearef.size();
			
			vector <unsigned int> areax1, areax2;
			for(auto j = 0u; j < num/2; j++) areax1.push_back(lev[l].node[c].arearef[j]);
			for(auto j = num/2; j < num; j++) areax2.push_back(lev[l].node[c].arearef[j]);
		
			geo_sort(areax1,Y);
			num = areax1.size(); if(num > 2) flag = 1;
			
			node.arearef.clear(); node.child.clear(); 
			for(auto j = 0u; j < num/2; j++) node.arearef.push_back(areax1[j]);

			if(node.arearef.size() > 0){
				node.parent = c;
				lev[l].node[c].child.push_back(lev[l+1].node.size());	
				lev[l+1].node.push_back(node);
			}

			node.arearef.clear(); node.child.clear();
			for(auto j = num/2; j < num; j++) node.arearef.push_back(areax1[j]);
			if(node.arearef.size() > 0){
				node.parent = c;
				lev[l].node[c].child.push_back(lev[l+1].node.size());	
				lev[l+1].node.push_back(node);
			}
			
			geo_sort(areax2,Y);
			num = areax2.size(); if(num > 2) flag = 1;
			
			node.arearef.clear(); node.child.clear(); 
			for(auto j = 0u; j < num/2; j++) node.arearef.push_back(areax2[j]);
			if(node.arearef.size() > 0){
				node.parent = c;
				lev[l].node[c].child.push_back(lev[l+1].node.size());	
				lev[l+1].node.push_back(node);
			}

			node.arearef.clear(); node.child.clear();
			for(auto j = num/2; j < num; j++) node.arearef.push_back(areax2[j]);
			if(node.arearef.size() > 0){
				node.parent = c;
				lev[l].node[c].child.push_back(lev[l+1].node.size());	
				lev[l+1].node.push_back(node);
			}
		}
		l++;
	}while(flag == 1);
 
	level = l+1;

	if(lev[l].node.size() != data.narea) emsgEC("Poptree",1);
	
	l = level-2;                                                             // Switches children so the last layer matches order
	auto cmax = lev[l].node.size();
	for(auto c = 0u; c < cmax; c++){
		auto jmax = lev[l].node[c].child.size();
		for(auto j = 0u; j < jmax; j++){
			auto cc = lev[l].node[c].child[j];
			if(lev[level-1].node[cc].arearef.size() != 1) emsgEC("Poptree",2);
			auto ccc = lev[level-1].node[cc].arearef[0];
			lev[l].node[c].child[j] = ccc;
			lev[level-1].node[ccc].parent = c;
		}		
	}
	for(auto c = 0u; c < data.narea; c++) lev[level-1].node[c].arearef[0] = c;
	
	for(auto& le : lev){   // Sets parameters for fixed parameter proposals
		for(auto& no : le.node){ 
			no.mbp_sim.resize(data.narea);
			for(auto& val : no.mbp_sim) val = MBP;
			for(auto& c : no.arearef) no.mbp_sim[c] = SIMU;
		}
	}
}


/// Used for sorting areas
static bool compAreaSort(AreaSort lhs, AreaSort rhs){ return lhs.num < rhs.num;};

/// Sorts areas defined in vec in the direction dir
void AreaTree::geo_sort(vector <unsigned int> &vec, Dir dir)
{
	vector <AreaSort> areasort;
	
	for(auto i = 0u; i < vec.size(); i++){
		AreaSort as;
		as.area = vec[i];
		switch(dir){
		case X: as.num = data.area[vec[i]].x; break;
		case Y: as.num = data.area[vec[i]].y; break;
		default: emsgEC("Areatree",34); break;
		}
		areasort.push_back(as);
	}
	
	sort(areasort.begin(),areasort.end(),compAreaSort);
	
	for(auto i = 0u; i < vec.size(); i++) vec[i] = areasort[i].area;
}
